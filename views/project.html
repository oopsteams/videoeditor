<!DOCTYPE html>
<html lang="cs" dir="ltr">
<head>
	<meta charset="UTF-8">
	<title>Online Videoeditor</title>
	<link rel="stylesheet" type="text/css" href="/fonts/iconfont/material-design-icons.css">
	<link rel="stylesheet" type="text/css" href="/vis.css">
	<link rel="stylesheet" type="text/css" href="/style.css">

	<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
	<link rel="manifest" href="/icons/site.webmanifest">
	<link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/icons/favicon.ico">
	<meta name="msapplication-TileColor" content="#2b5797">
	<meta name="msapplication-config" content="/icons/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
</head>
<body>
	<div id="app">
		<div class="modal">
			<h2>加载视频编辑器</h2>
			<div>
				<div class="loader"></div><br>
				如果应用程序未被读取，请尝试以下操作:<br>
				1. 您已启用JavaScript?<br>
				2. 刷新浏览器是否正常?<br>
				3. 网络连接是否正常?
			</div>
		</div>
	</div>
	<script src="/main.js" async></script>
	<div id="overlay">
		<button id="startButton">Play</button>
	</div>
	<div id="container"></div>
	<div id="info">
				<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl video demo<br/>
				playing <a href="http://durian.blender.org/" target="_blank" rel="noopener">sintel</a> trailer
			</div>
	
	<video id="video" loop crossOrigin="anonymous" playsinline style="display:">
		<source src="/three/textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
		<source src="/three/textures/sintel.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
	</video>
	<script type="module">
	
				import * as THREE from '/three/build/three.module.js';
	
				import { EffectComposer } from '/three/lib/jsm/postprocessing/EffectComposer.js';
				import { RenderPass } from '/three/lib/jsm/postprocessing/RenderPass.js';
				import { ShaderPass } from '/three/lib/jsm/postprocessing/ShaderPass.js';
				import { BloomPass } from '/three/lib/jsm/postprocessing/BloomPass.js';
				import { CopyShader } from '/three/lib/jsm/shaders/CopyShader.js';
	
				var container;
	
				var camera, scene, renderer;
	
				var video, texture, material, mesh;
	
				var composer;
	
				var mouseX = 0;
				var mouseY = 0;
	
				var windowHalfX = window.innerWidth / 2;
				var windowHalfY = window.innerHeight / 2;
	
				var cube_count,
	
					meshes = [],
					materials = [],
	
					xgrid = 20,
					ygrid = 10;
	
				var startButton = document.getElementById( 'startButton' );
				startButton.addEventListener( 'click', function () {
	
					init();
					animate();
	
				}, false );
	
				function init() {
	
					var overlay = document.getElementById( 'overlay' );
					overlay.remove();
	
					container = document.createElement( 'div' );
					document.body.appendChild( container );
	
					camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
					camera.position.z = 500;
	
					scene = new THREE.Scene();
	
					var light = new THREE.DirectionalLight( 0xffffff );
					light.position.set( 0.5, 1, 1 ).normalize();
					scene.add( light );
	
					renderer = new THREE.WebGLRenderer();
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );
	
					video = document.getElementById( 'video' );
					video.play();
					video.addEventListener('play', function() {
						this.currentTime = 3;
					}, false);
	
					texture = new THREE.VideoTexture( video );
	
					//
	
					var i, j, ux, uy, ox, oy,
						geometry,
						xsize, ysize;
	
					ux = 1 / xgrid;
					uy = 1 / ygrid;
	
					xsize = 480 / xgrid;
					ysize = 204 / ygrid;
	
					var parameters = { color: 0xffffff, map: texture };
	
					cube_count = 0;
	
					for ( i = 0; i < xgrid; i ++ )
						for ( j = 0; j < ygrid; j ++ ) {
	
							ox = i;
							oy = j;
	
							geometry = new THREE.BoxBufferGeometry( xsize, ysize, xsize );
	
							change_uvs( geometry, ux, uy, ox, oy );
	
							materials[ cube_count ] = new THREE.MeshLambertMaterial( parameters );
	
							material = materials[ cube_count ];
	
							material.hue = i / xgrid;
							material.saturation = 1 - j / ygrid;
	
							material.color.setHSL( material.hue, material.saturation, 0.5 );
	
							mesh = new THREE.Mesh( geometry, material );
	
							mesh.position.x = ( i - xgrid / 2 ) * xsize;
							mesh.position.y = ( j - ygrid / 2 ) * ysize;
							mesh.position.z = 0;
	
							mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
	
							scene.add( mesh );
	
							mesh.dx = 0.001 * ( 0.5 - Math.random() );
							mesh.dy = 0.001 * ( 0.5 - Math.random() );
	
							meshes[ cube_count ] = mesh;
	
							cube_count += 1;
	
						}
	
					renderer.autoClear = false;
	
					document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	
					// postprocessing
	
					var renderModel = new RenderPass( scene, camera );
					var effectBloom = new BloomPass( 1.3 );
					var effectCopy = new ShaderPass( CopyShader );
	
					composer = new EffectComposer( renderer );
	
					composer.addPass( renderModel );
					composer.addPass( effectBloom );
					composer.addPass( effectCopy );
	
					//
	
					window.addEventListener( 'resize', onWindowResize, false );
					
					scene.onAfterRender = function(_renderer, scene, camera, geometry, material, group){
						// let canvas = renderer.domElement;
						// let canvas = container.querySelector('canvas');
						// console.log("querySelector canvas!");
						let canvas = window.rend.domElement;
						cut_canvas(canvas);
					};
					window.three_con = container;
					window.rend = renderer;
				}
	
				function onWindowResize() {
	
					windowHalfX = window.innerWidth / 2;
					windowHalfY = window.innerHeight / 2;
	
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
	
					renderer.setSize( window.innerWidth, window.innerHeight );
					composer.setSize( window.innerWidth, window.innerHeight );
	
				}
	
				function change_uvs( geometry, unitx, unity, offsetx, offsety ) {
	
					var uvs = geometry.attributes.uv.array;
	
					for ( var i = 0; i < uvs.length; i += 2 ) {
	
						uvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;
						uvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;
	
					}
	
				}
	
	
				function onDocumentMouseMove( event ) {
	
					mouseX = ( event.clientX - windowHalfX );
					mouseY = ( event.clientY - windowHalfY ) * 0.3;
	
				}
	
				//
				var clock = new THREE.Clock();
				var FPS = 24;
				var renderT = 1/FPS;
				var timeS = 0;
				function animate() {
					// requestAnimationFrame( animate );
					var T = clock.getDelta();
					timeS = timeS + T;
					if(timeS > renderT){
						timeS = 0;
						render();
					}
				}
				
				window.animate = animate;
				var h, counter = 1;
				
				//////////////////////////////////////////////////////cut canvas
				var readers = [];
				var getBlobReader=function(){
					for(var i=0;i<readers.length;i++){
						var r = readers[i];
						console.log("check reader index:"+i);
						if(r.pin==0){
							r.pin=1;
							r.rs=null;
							return r;
						}
					}
					var _r = {"pin":1,"fr":new FileReader(),"cb":null};
					_r.fr.p=_r;
					_r.fr.onload=function(evt){
						if(evt.target.readyState == FileReader.DONE){
							// this.p.pin=0;
							if(this.p.cb)this.p.cb(new Uint8Array(this.result));
						}
					};
					readers[readers.length]=_r;
					return _r;
				}
				var blobToArray=function(b,cb){
					var r = getBlobReader();
					if(r){
						r.cb=cb;
						r.fr.readAsArrayBuffer(b);
					}
				};
				var file = function(buffer){
					this.defaults = {
					    ext              : 'png',
					    remoteFileName   : 'test',
					    localUrl         : null,
					    localFile        : buffer,
					    size             : buffer.length,
					    encodingProgress : 0,
					    byteOffset       : 0,
					    isComplete       : false,
					    isOriginal       : false
					},
					this.get = function(key){
						
						if(this.defaults.hasOwnProperty(key)){
							return this.defaults[key];
						}
						return null;
					}
				};
				function cut_canvas(cvs){
					cvs.toBlob(function(blob){
					            blobToArray(blob,function(buffer){
					                        console.log(buffer);
											
										window.uploader.addFile(new file(buffer));
										window.uploader.start();
					            });
					        });
				}
				window.cut_canvas = cut_canvas;
				//////////////////////////////////////////////////////cut canvas end
				function render() {
	
					var time = Date.now() * 0.00005;
	
					camera.position.x += ( mouseX - camera.position.x ) * 0.05;
					camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
	
					camera.lookAt( scene.position );
	
					for ( var i = 0; i < cube_count; i ++ ) {
	
						material = materials[ i ];
	
						h = ( 360 * ( material.hue + time ) % 360 ) / 360;
						material.color.setHSL( h, material.saturation, 0.5 );
	
					}
	
					if ( counter % 1000 > 200 ) {
	
						for ( var i = 0; i < cube_count; i ++ ) {
	
							mesh = meshes[ i ];
	
							mesh.rotation.x += 10 * mesh.dx;
							mesh.rotation.y += 10 * mesh.dy;
	
							mesh.position.x -= 150 * mesh.dx;
							mesh.position.y += 150 * mesh.dy;
							mesh.position.z += 300 * mesh.dx;
	
						}
	
					}
	
					if ( counter % 1000 === 0 ) {
	
						for ( var i = 0; i < cube_count; i ++ ) {
	
							mesh = meshes[ i ];
	
							mesh.dx *= - 1;
							mesh.dy *= - 1;
	
						}
	
					}
	
					counter ++;
					
					renderer.clear();
					composer.render();
					window.rend = renderer;
				}
	
	
			</script>
</body>
</html>

<!DOCTYPE html>
<html lang="cs" dir="ltr">
<head>
	<meta charset="UTF-8">
	<title>Online Videoeditor</title>
	<link rel="stylesheet" type="text/css" href="/fonts/iconfont/material-design-icons.css">
	<link rel="stylesheet" type="text/css" href="/vis.css">
	<link rel="stylesheet" type="text/css" href="/style.css">

	<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
	<link rel="manifest" href="/icons/site.webmanifest">
	<link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/icons/favicon.ico">
	<meta name="msapplication-TileColor" content="#2b5797">
	<meta name="msapplication-config" content="/icons/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
</head>
<body>
	<div id="app">
		<div class="modal">
			<h2>加载视频编辑器</h2>
			<div>
				<div class="loader"></div><br>
				如果应用程序未被读取，请尝试以下操作:<br>
				1. 您已启用JavaScript?<br>
				2. 刷新浏览器是否正常?<br>
				3. 网络连接是否正常?
			</div>
		</div>
	</div>
	<script src="/main.js" async></script>
	<canvas id="d3-canvas"></canvas>
	<div id="overlay">
		<button id="startButton">Play</button>
		<button id="testButton">Test</button>
	</div>
	<div id="container"></div>
	<div id="info">
				<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl video demo<br/>
				playing <a href="http://durian.blender.org/" target="_blank" rel="noopener">sintel</a> trailer
			</div>
	
	<video id="video" loop crossOrigin="anonymous" playsinline style="display:;" muted autoplay="true">
		<source src="/three/textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
		<source src="/three/textures/sintel.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
	</video>
	<canvas id="drawing-canvas" height="960" width="480"></canvas>
	<canvas id="drawing-canvas2" height="480" width="240"></canvas>
	<script type="module">
		
		
		function to_upload(){
			var total_size = 0;
			
			var chunks = window.blob_cache;
			chunks.forEach((c)=>{
				total_size += c.length;
			});
			var query = {
				fileSize: total_size,
				nextOffset: 0
			};
		}
		// 执行上传
		function upload(chunks, query, cb) {
		    var queryStr = Object.getOwnPropertyNames(query).map(key => {
		        return key + "=" + query[key];
		    }).join("&");
		    var xhr = new XMLHttpRequest();
		    xhr.open("POST", "http://xxxx/opload?" + queryStr);
		    xhr.overrideMimeType("application/octet-stream");
		    
		    //获取post body中二进制数据
		    var index = Math.floor(query.nextOffset / query.dataSize);
		    if (xhr.sendAsBinary) {
		        xhr.sendAsBinary(binary);
		    } else {
		        xhr.send(binary);
		    }
		
		    xhr.onreadystatechange = function (e) {
		        if (xhr.readyState === 4) {
		            if (xhr.status === 200) {
		                var resp = JSON.parse(xhr.responseText);
		                // 接口返回nextoffset
		                // resp = {
		                //     isFinish:false,
		                //     offset:100*1024
		                // }
		                if (typeof cb === "function") {
		                    cb.call(this, resp, chunks, query)
		                }
		            }
		        }
		    }
		}
		var _upload_blob = function(fn, bdata){
			var u = window.upload_url + "/" + fn;
			console.log("u url:", u);
			var fd = new FormData();
			fd.append("file", bdata);
			fetch(u,{ 
			    method :"POST",
			    body: formData,
			    headers:{
			        "Content-Type": "multipart/form-data"
			    } 
			}).then(response => response.json())
			.then(data => {
				if (typeof data.err === 'undefined') {
					console.log("res data:", data);
				}
				else {
					alert(`${data.err}\n\n${data.msg}`);
				}
			})
			.catch(error => this.props.fetchError(error.message));
		}
		// 每片上传成功后执行
		function successPerUpload(resp, chunks, query) {
		    if (resp.isFinish === true) {
		        alert("上传成功");
		    } else {
		        //未上传完毕
		        query.offset = resp.offset;
		        upload(chunks, query, successPerUpload);
		    }
		}
		
		
		
		console.log("will import modules.........................");
				var container_id = 'preview-player';
				import Effects from '/js/effects-fonts.js';
				import SwiperEffects from '/js/boom-swiper.js';
				import CSwiperEffects from '/js/common-swiper.js';
				import * as THREE from '/three/build/three.module.js';
	
				import { EffectComposer } from '/three/lib/jsm/postprocessing/EffectComposer.js';
				import { RenderPass } from '/three/lib/jsm/postprocessing/RenderPass.js';
				import { ShaderPass } from '/three/lib/jsm/postprocessing/ShaderPass.js';
				import { BloomPass } from '/three/lib/jsm/postprocessing/BloomPass.js';
				import { CopyShader } from '/three/lib/jsm/shaders/CopyShader.js';
				var effects, swiper, cswiper;
				var container;
	
				var camera, scene, renderer;
	
				var video, texture, material, mesh;
	
				var composer;
	
				var mouseX = 0;
				var mouseY = 0;
	
				var windowHalfX = window.innerWidth / 2;
				var windowHalfY = window.innerHeight / 2;
	
				var cube_count,
	
					meshes = [],
					materials = [],
	
					xgrid = 20,
					ygrid = 10;
	
				var startButton = document.getElementById( 'startButton' );
				var to_start = function(){
					var root_elem = document.getElementById(container_id);
					init();
					cswiper.start();
					animate();
				};
				window.to_start = to_start;
				function check_to_start(){
					if(window.view_ready){
						window.to_start();
					} else {
						console.log("not ready!!");
						setTimeout(check_to_start, 1000);
					}
				}
				setTimeout(check_to_start, 1000);
				// setTimeout(to_start, 1000);
				startButton.addEventListener( 'click', function () {
	
					init();
					// swiper_init();
					cswiper.start();
					animate();
					// swiper.start();
				}, false );
				function init(){
					var root_elem = document.getElementById(container_id);
					cswiper = new CSwiperEffects(container, '你们好!');
					var base = cswiper.init(null, null, null, root_elem);
					scene = base[0];
					camera = base[1];
					renderer = base[2];
				}
				function swiper_init(){
					var overlay = document.getElementById( 'overlay' );
					overlay.remove();
						
					container = document.createElement( 'div' );
					document.body.appendChild( container );
						
					camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
					camera.position.z = 500;
						
					scene = new THREE.Scene();
						
					var light = new THREE.DirectionalLight( 0xffffff );
					light.position.set( 0.5, 1, 1 ).normalize();
					scene.add( light );
					
					////////////////////////////add
					var pointLight = new THREE.PointLight( 0xffffff, 1.5 );
					pointLight.position.set( 0, 100, 90 );
					pointLight.name = "pointLight1";
					scene.add( pointLight );
					//////////////////////////////////
					renderer = new THREE.WebGLRenderer({antialias: true});
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );
					
					swiper = new SwiperEffects(container, 'video');
					swiper.init(scene, camera, renderer);
				}
				function init2() {
					container = document.createElement( 'div' );
					document.body.appendChild( container );
					camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
									camera.position.set( 0, 400, 700 );
					scene = new THREE.Scene();
					scene.background = new THREE.Color( 0x000000 );
					scene.fog = new THREE.Fog( 0x000000, 250, 1400 );
					
					var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
					dirLight.position.set( 0, 0, 1 ).normalize();
					scene.add( dirLight );
	
					var pointLight = new THREE.PointLight( 0xffffff, 1.5 );
					pointLight.position.set( 0, 100, 90 );
					pointLight.name = "pointLight1";
					scene.add( pointLight );
					
					renderer = new THREE.WebGLRenderer( { antialias: true } );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );
					
					renderer.autoClear = false;
					
					effects = new Effects(container, "风塘美术");
					// effects = new Effects(container, "FengTangMeiShu");
					effects.init(scene, camera, renderer);
				}
	
				function init1() {
	
					var overlay = document.getElementById( 'overlay' );
					overlay.remove();
	
					container = document.createElement( 'div' );
					document.body.appendChild( container );
	
					camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
					camera.position.z = 500;
	
					scene = new THREE.Scene();
	
					var light = new THREE.DirectionalLight( 0xffffff , 0.5);
					light.position.set( 0.5, 1, 1 ).normalize();
					scene.add( light );
					
					////////////////////////////add
					var pointLight = new THREE.PointLight( 0xffffff, 1.5 );
					pointLight.position.set( 0, 100, 90 );
					pointLight.name = "pointLight1";
					scene.add( pointLight );
					//////////////////////////////////
					renderer = new THREE.WebGLRenderer();
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );
	
	
	
					video = document.getElementById( 'video' );
					video.play();
					video.addEventListener('play', function() {
						this.currentTime = 3;
					}, false);
	
					texture = new THREE.VideoTexture( video );
	
					//
	
					var i, j, ux, uy, ox, oy,
						geometry,
						xsize, ysize;
	
					ux = 1 / xgrid;
					uy = 1 / ygrid;
	
					xsize = 480 / xgrid;
					ysize = 204 / ygrid;
	
					var parameters = { color: 0xffffff, map: texture };
	
					cube_count = 0;
	
					for ( i = 0; i < xgrid; i ++ )
						for ( j = 0; j < ygrid; j ++ ) {
	
							ox = i;
							oy = j;
	
							geometry = new THREE.BoxBufferGeometry( xsize, ysize, xsize );
	
							change_uvs( geometry, ux, uy, ox, oy );
	
							materials[ cube_count ] = new THREE.MeshLambertMaterial( parameters );
	
							material = materials[ cube_count ];
	
							material.hue = i / xgrid;
							material.saturation = 1 - j / ygrid;
	
							material.color.setHSL( material.hue, material.saturation, 0.5 );
	
							mesh = new THREE.Mesh( geometry, material );
	
							mesh.position.x = ( i - xgrid / 2 ) * xsize;
							mesh.position.y = ( j - ygrid / 2 ) * ysize;
							mesh.position.z = 0;
	
							mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
	
							scene.add( mesh );
	
							mesh.dx = 0.001 * ( 0.5 - Math.random() );
							mesh.dy = 0.001 * ( 0.5 - Math.random() );
	
							meshes[ cube_count ] = mesh;
	
							cube_count += 1;
	
						}
	
					renderer.autoClear = false;
	
					document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	
					// postprocessing
	
					var renderModel = new RenderPass( scene, camera );
					var effectBloom = new BloomPass( 1.3 );
					var effectCopy = new ShaderPass( CopyShader );
	
					composer = new EffectComposer( renderer );
	
					composer.addPass( renderModel );
					composer.addPass( effectBloom );
					composer.addPass( effectCopy );
	
					//
	
					window.addEventListener( 'resize', onWindowResize, false );
					
					scene.onAfterRender = function(_renderer, scene, camera, geometry, material, group){
						// let canvas = renderer.domElement;
						// let canvas = container.querySelector('canvas');
						// console.log("querySelector canvas!");
						
					};
					window.three_con = container;
					window.rend = renderer;
					effects = new Effects(container, "风塘美术");
					// effects = new Effects(container, "FengTangMeiShu");
					effects.init(scene, camera, renderer);
					
				}
	
				function onWindowResize() {
	
					windowHalfX = window.innerWidth / 2;
					windowHalfY = window.innerHeight / 2;
	
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
	
					renderer.setSize( window.innerWidth, window.innerHeight );
					composer.setSize( window.innerWidth, window.innerHeight );
	
				}
	
				function change_uvs( geometry, unitx, unity, offsetx, offsety ) {
	
					var uvs = geometry.attributes.uv.array;
	
					for ( var i = 0; i < uvs.length; i += 2 ) {
	
						uvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;
						uvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;
	
					}
	
				}
	
	
				function onDocumentMouseMove( event ) {
	
					mouseX = ( event.clientX - windowHalfX );
					mouseY = ( event.clientY - windowHalfY ) * 0.3;
	
				}
	
				//
				var clock = new THREE.Clock();
				window.clock = clock;
				var FPS = 24;
				var renderT = 1/FPS;
				var timeS = 0;
				function animate() {
					// requestAnimationFrame( animate );
					// video.play();
					var T = clock.getDelta();
					// console.log("getDelta:", T, ",renderT:", renderT);
					// timeS = timeS + T;
					if(timeS > renderT){
						timeS = 0;
						// video.pause();
						render();
					} else {
						timeS = timeS + T;
						requestAnimationFrame( animate );
					}
				}
				
				window.animate = animate;
				var h, counter = 1;
				
				//////////////////////////////////////////////////////cut canvas
				var readers = [];
				var getBlobReader=function(){
					for(var i=0;i<readers.length;i++){
						var r = readers[i];
						console.log("check reader index:"+i);
						if(r.pin==0){
							r.pin=1;
							r.rs=null;
							return r;
						}
					}
					var _r = {"pin":1,"fr":new FileReader(),"cb":null};
					_r.fr.p=_r;
					_r.fr.onload=function(evt){
						if(evt.target.readyState == FileReader.DONE){
							this.p.pin=0;
							if(this.p.cb)this.p.cb(new Uint8Array(this.result));
						}
					};
					readers[readers.length]=_r;
					return _r;
				}
				var blobToArray=function(b,cb){
					var r = getBlobReader();
					if(r){
						r.cb=cb;
						r.fr.readAsArrayBuffer(b);
					}
				};
				var file = function(part, pos, buffer){
					var pre_name = "0000"+pos;
					pre_name = pre_name.substring(pre_name.length-4);
					this.defaults = {
						part             :part,
					    ext              : 'png',
					    remoteFileName   : pre_name+'.png',
					    localUrl         : null,
					    localFile        : buffer,
					    size             : buffer.length,
					    encodingProgress : 0,
					    byteOffset       : 0,
					    isComplete       : false,
					    isOriginal       : false
					},
					this.get = function(key){
						
						if(this.defaults.hasOwnProperty(key)){
							return this.defaults[key];
						}
						return null;
					}
				};
				var len = 11 * FPS;
				var blob_cache=[];
				window.blob_cache = blob_cache;
				function cut_canvas(cvs, cb){
					cvs.toBlob(function(blob){
								/*
					            blobToArray(blob,function(buffer){
					                        console.log(buffer);
											
										window.uploader.addFile(new file(buffer));
										window.uploader.start();
					            });
								*/
							   // blob_cache.push(blob);
							   if(blob_cache.length<len){
								   if(cb)cb();
							   } else {
								   console.log("cut_canvas ok! 2s willsend. blob_cache len:", blob_cache.length);
								   // console.log("blob_cache:", blob_cache);
								   setTimeout(function(){
									   //window.loop_uploader();
									   _upload_blob('0001.png', blob_cache[0]);
								   }, 2000);
							   }
							   
					        });
				}
				window.cut_canvas = cut_canvas;
				window.loop_uploader = function(){
					var part = 0;
					var pos = 0;
					var l = blob_cache.length;
					var t_up=function(){
						if(pos<l){
							var _pos = pos;
							pos ++;
							blobToArray(blob_cache[_pos],function(buffer){
							            // console.log(buffer);
									
									window.uploader.addFile(new file(part, _pos, buffer));
									window.uploader.start();
									//window.setTimeout(t_up,2000);
							});
							
						} else {
							
						}
					}
					t_up();
					window.socket.on("file/"+part+":update", function(data){
						console.log("on update data pos:", pos);
						t_up();
						
					});
					
				}
				// ffmpeg -y -r 24 -i ./%04d.png -vcodec libx264 -t 10 0.mp4
				//////////////////////////////////////////////////////cut canvas end
				function render(){
					// var t = effects.render(scene, camera, renderer);
					camera.lookAt( scene.position );
					cswiper.render(scene, camera, renderer);
					renderer.clear();
					renderer.render( scene, camera );
					
					let canvas = renderer.domElement;
					if(cswiper.record){
						cut_canvas(canvas, function(){
							requestAnimationFrame( window.animate );
						});
					} else {
						requestAnimationFrame( window.animate );
					}
					// requestAnimationFrame( window.animate );
				}
				function render2(){
					var t = effects.render(scene, camera, renderer);
					camera.lookAt( t );
					renderer.clear();
					renderer.render( scene, camera );
					requestAnimationFrame( window.animate );
				}
				function render1() {
	
					var time = Date.now() * 0.00005;
	
					camera.position.x += ( mouseX - camera.position.x ) * 0.05;
					camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
	
					var t = effects.render(scene, camera, renderer);
	
					camera.lookAt( scene.position );
	
					for ( var i = 0; i < cube_count; i ++ ) {
	
						material = materials[ i ];
	
						h = ( 360 * ( material.hue + time ) % 360 ) / 360;
						material.color.setHSL( h, material.saturation, 0.5 );
	
					}
	
					if ( counter % 1000 > 200 ) {
	
						for ( var i = 0; i < cube_count; i ++ ) {
	
							mesh = meshes[ i ];
	
							mesh.rotation.x += 10 * mesh.dx;
							mesh.rotation.y += 10 * mesh.dy;
	
							mesh.position.x -= 150 * mesh.dx;
							mesh.position.y += 150 * mesh.dy;
							mesh.position.z += 300 * mesh.dx;
	
						}
	
					}
	
					if ( counter % 1000 === 0 ) {
	
						for ( var i = 0; i < cube_count; i ++ ) {
	
							mesh = meshes[ i ];
	
							mesh.dx *= - 1;
							mesh.dy *= - 1;
	
						}
	
					}
	
					counter ++;
					
					// effects.render(scene, camera, renderer);
					
					renderer.clear();
					composer.render();
					window.rend = renderer;
					let canvas = window.rend.domElement;
					cut_canvas(canvas, function(){
						requestAnimationFrame( window.animate );
					});
					// requestAnimationFrame( window.animate );
				}
	
	
			</script>
</body>
</html>
